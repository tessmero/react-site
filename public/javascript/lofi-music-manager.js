const _scalesAndChords={offClick:[0,7,4,0],goodClick:[0,4,7,7],dullClick:[0,2,0],majorArp:[0,4,7,12],majorScale:[0,2,4,5,7,9,11],minorScale:[0,2,3,5,7,8,10],naturalMinorScale:[0,2,3,5,7,8,10],harmonicMinorScale:[0,2,3,5,7,8,11],melodicMinorScale:[0,2,3,5,7,9,11],pentatonicMajorScale:[0,2,4,7,9],pentatonicMinorScale:[0,3,5,7,10],bluesScale:[0,3,5,6,7,10],chromaticScale:[0,1,2,3,4,5,6,7,8,9,10,11],majorChord:[0,4,7],minorChord:[0,3,7],diminishedChord:[0,3,6],augmentedChord:[0,4,8],majorSeventhChord:[0,4,7,11],minorSeventhChord:[0,3,7,10],dominantSeventhChord:[0,4,7,10],halfDiminishedSeventhChord:[0,3,6,10],diminishedSeventhChord:[0,3,6,9]};const _namedNotes={A2:110,"A#2":116.54,B2:123.47,C3:130.81,"C#3":138.59,D3:146.83,"D#3":155.56,E3:164.81,F3:174.61,"F#3":185,G3:196,"G#3":207.65,A3:220,"A#3":233.08,B3:246.94,C4:261.63,"C#4":277.18,D4:293.66,"D#4":311.13,E4:329.63,F4:349.23,"F#4":369.99,G4:392,"G#4":415.3,A4:440,"A#4":466.16,B4:493.88,C5:523.25,"C#5":554.37,D5:587.33,"D#5":622.25,E5:659.25,F5:698.46,"F#5":739.99,G5:783.99,"G#5":830.61,A5:880};function musicFreqs(rootNoteName,scaleName){const scaleSteps=_scalesAndChords[scaleName];const noteNames=Object.keys(_namedNotes);const rootIndex=noteNames.indexOf(rootNoteName);const scale=[];for(const step of scaleSteps){const noteIndex=(rootIndex+step)%noteNames.length;noteName=noteNames[noteIndex];scale.push(_namedNotes[noteName])}return scale}var musicScoreVolume=1;class SongParser{static getScheduler(songData,startTime){const parser=new SongParser(songData,startTime);return(t,dur)=>parser.scheduleNotes(t,dur)}#songData;#startTime;#endTime;#beatIndex=0;#measureIndex=0;#beatInMeasureByVoice={};#editScore;#scoreEnv;constructor(songData,startTime){this.#songData=songData;this.#startTime=startTime;let nBeats=0;songData.score.forEach(group=>{nBeats=nBeats+group[0].length});const songDur=songData.voices[0].duration*nBeats;this.#endTime=songDur;this.#editScore=JSON.parse(JSON.stringify(songData.score))}_oncePerBeatCheck(time){if(this.#scoreEnv){const{start:t0,end:t1}=this.#scoreEnv;const r=(t1-time)/(t1-t0);musicScoreVolume=r}else{musicScoreVolume=1}}_oncePerMeasureCheck(measureIndex,time){const{voices}=this.#songData;const score=this.#editScore;if(score[measureIndex].length>voices.length){const{start}=score[measureIndex][voices.length];if(start){this.#scoreEnv={start:time,end:this.#endTime}}}}scheduleNotes(t,dur){const time=t-this.#startTime;if(time>this.#endTime){return{finished:true}}const{voices}=this.#songData;const score=this.#editScore;voices.forEach((voice,voiceIndex)=>{const beatDur=voice.duration;const beatIndex=Math.floor(time/beatDur);const nextIndex=Math.floor((time+dur)/beatDur);if(beatIndex===nextIndex){return}this.#beatIndex=beatIndex;const{measureIndex,scoreVal,beatInMeasure}=this._getScoreVal(score,voiceIndex,beatIndex-1);this.#beatInMeasureByVoice[voiceIndex]=beatInMeasure;this.#measureIndex=measureIndex;if(voiceIndex===0&&beatInMeasure===0){this._oncePerMeasureCheck(measureIndex,time)}if(voiceIndex===0){this._oncePerBeatCheck(time)}if(typeof scoreVal!=="number"){return}const freq=_namedNotes[SongParser.getNoteName(voice,scoreVal)];if(typeof freq!=="number"){return}let duration=voice.duration;let i=beatIndex;while(this._getScoreVal(score,voiceIndex,i).scoreVal==="sustain"){duration=duration+voice.duration;i++}const beatTime=this.#startTime+beatDur*beatIndex;if(voice.endFreq){new SoundEffect({...voice,duration:duration}).schedulePlay(beatTime+.2)}else{new SoundEffect({...voice,freq:freq,duration:duration}).schedulePlay(beatTime+.2)}score[measureIndex][voiceIndex][beatInMeasure]="rest"});return{measure:this.#measureIndex,beat:this.#beatIndex,finished:false,beatInMeasure:voices.map((_voice,voiceIndex)=>this._getBeatInMeasure(voiceIndex))}}static getNoteName(voice,scoreVal){const noteIndex=scoreVal+Object.keys(_namedNotes).indexOf(voice.freq);return Object.keys(_namedNotes)[noteIndex]}_getScoreVal(score,voiceIndex,beatIndex){let i=0;let measureIndex=0;for(const measure of score){const nbeats=measure[voiceIndex].length;if(i+nbeats<=beatIndex){i=i+nbeats}else{return{measureIndex:measureIndex,beatInMeasure:beatIndex-i,scoreVal:measure[voiceIndex][beatIndex-i]}}measureIndex++}return{}}_getBeatInMeasure(voiceIndex){if(Object.hasOwn(this.#beatInMeasureByVoice,voiceIndex)){return this.#beatInMeasureByVoice[voiceIndex]}return-1}}class SoundEffect{#duration;#envelope;#minDelay;#lastPlayTime;#scale;#startFreq;#endFreq;#wave;constructor(params={}){const{volume,duration,env="dropEnd",minDelay,freq,startFreq,endFreq,scale,wave}=params;this.#duration=duration;this.#minDelay=minDelay;if(scale){if(Array.isArray(scale)){this.#scale=scale}else{const[rootNote,scaleName]=scale.split("_");this.#scale=musicFreqs(rootNote,scaleName)}}else if(freq){this.#startFreq=freq;this.#endFreq=freq}else{this.#startFreq=startFreq;this.#endFreq=endFreq}this.#wave=wave;this.#envelope=new SoundEnvelope({volume:volume,duration:duration,env:env})}setScale(rootNote,scaleName){this.#scale=musicFreqs(rootNote,scaleName)}schedulePlay(time){this.play(null,time)}play(position,t=null){const mgr=MusicManager();const ac=mgr._ac;if(ac.state==="suspended"){ac.resume()}const time=t?t:ac.currentTime;if(!time){return}const outNode=mgr.outNode;if(this.#minDelay){if(this.#lastPlayTime){const dt=time-this.#lastPlayTime;if(dt<this.#minDelay){return}}this.#lastPlayTime=time}const startTime=time;const endTime=startTime+this.#duration;const osc=ac.createOscillator();if(this.#wave==="sh"){this._playShSound(ac,outNode,startTime,endTime)}else{osc.type=this.#wave;if(this.#scale){this.#scale.forEach((freq,i)=>{const freqTime=startTime+i*this.#duration/(this.#scale.length+2);osc.frequency.setValueAtTime(freq,freqTime)})}else{osc.frequency.setValueAtTime(this.#startFreq,startTime);osc.frequency.exponentialRampToValueAtTime(this.#endFreq,endTime)}const gainNode=ac.createGain();this.#envelope.applyEnvelope(gainNode,startTime);osc.connect(gainNode);gainNode.connect(outNode);osc.start(startTime);osc.stop(endTime)}}_playShSound(ac,outNode,startTime,endTime){const sampleRate=ac.sampleRate;const bufferSize=sampleRate*this.#duration;const buffer=ac.createBuffer(1,bufferSize,sampleRate);const data=buffer.getChannelData(0);for(let i=0;i<bufferSize;i++){data[i]=Math.random()*2-1}const source=ac.createBufferSource();source.buffer=buffer;const filter=ac.createBiquadFilter();filter.type="lowpass";filter.frequency.setValueAtTime(this.#startFreq*10,startTime);filter.frequency.linearRampToValueAtTime(this.#endFreq*10,endTime);const gainNode=ac.createGain();this.#envelope.applyEnvelope(gainNode,startTime);source.connect(filter);filter.connect(gainNode);gainNode.connect(outNode);source.start(startTime);source.stop(endTime)}}class SoundEnvelope{#vt;#repeatDur;#volume;#duration;constructor(params={}){const{volume,duration,env}=params;this.#volume=volume;this.#duration=duration;this.#vt=SOUND_ENVELOPES[env].flatMap(point=>{if(Object.hasOwn(point,"repeat")){this.#repeatDur=point.repeat;return[]}let time;if(Object.hasOwn(point,"start")){time=this._parseVal(point.start,duration)}else if(Object.hasOwn(point,"end")){time=duration-this._parseVal(point.end,duration)}return[{time:time,volume:this._parseVal(point.volume,volume)}]})}get volume(){return this.#volume}_parseVal(value,reference){if(typeof value==="string"&&value.endsWith("%")){return parseFloat(value)/100*reference}return value*reference}applyEnvelope(gainNode,startTime){let repOffset=0;let first=true;while(repOffset<this.#duration){for(const{volume,time}of this.#vt){let realVol=volume*musicScoreVolume;realVol=Math.max(1e-5,realVol);const absoluteTime=startTime+repOffset+time;realVol=absoluteTime<.1?1e-10:realVol;if(first){gainNode.gain.setValueAtTime(realVol,absoluteTime);first=false}else{gainNode.gain.exponentialRampToValueAtTime(realVol,absoluteTime)}}if(this.#repeatDur){repOffset=repOffset+this.#repeatDur}else{return}}}}function MusicManager(){if(MusicManager._instance){return MusicManager._instance}if(!(this instanceof MusicManager)){return new MusicManager}MusicManager._instance=this;setInterval(()=>this._loop(),15);this._step=100/1e3;this._lookAhead=this._step;this._lastSnData={measure:0,beat:0};this._ac=new AudioContext;const gainNode=this._ac.createGain();gainNode.gain.value=.5;gainNode.connect(this._ac.destination);this.outNode=gainNode;this.mainMusicLoop=function(time,dur){this._lastSnData=this._songScheduler(time,1.5*dur);if(this._lastSnData.finished){this._playing=false}};this.isPlaying=function(){return this._playing&&this._ac.state!=="suspended"};this.getPlayingBeatIndex=function(){if(this._playing){return this._lastSnData}return null};this.getBeatInMeasure=function(voiceIndex){if(!this._playing){return-1}if(!this._lastSnData.beatInMeasure){return-1}return this._lastSnData.beatInMeasure[voiceIndex]};this.stopMusic=function(){this._playing=false;this._ac.close();MusicManager._instance=null};this.setSong=function(songData){if(this._playing&&this._currentSongTitleKey===songData.titleKey){return}this.startMusicLoop(songData)};this.startMusicLoop=function(songData=null,skipTime=0){const data=songData||SONGS['orbital-launch'];this.songData=data;this._currentSongTitleKey=data.titleKey;this._lastMusicLoop=this._ac.currentTime;this._songStartTime=this._ac.currentTime-skipTime;this._songScheduler=SongParser.getScheduler(data,this._songStartTime);this._ac.resume();this._playing=true};this._loop=function(){if(this._playing){const diff=this._ac.currentTime-this._lastMusicLoop;if(diff>=this._lookAhead){const nextNote=this._lastMusicLoop+this._step;this.mainMusicLoop(nextNote,this._step);this._lastMusicLoop=nextNote}}}}SOUND_ENVELOPES={dropEnd:[{start:0,volume:"100%"},{end:.1,volume:"100%"},{end:0,volume:0}],swoosh:[{start:0,volume:"10%"},{start:"50%",volume:"100%"},{end:0,volume:0}],bachBass:[{start:0,volume:"100%"},{end:.1,volume:"20%"},{end:0,volume:0}],attack:[{start:0,volume:"100%"},{end:0,volume:0}],zipper:[{start:0,volume:"100%"},{start:.0199,volume:"100%"},{start:.02,volume:0},{start:.0399,volume:0},{repeat:.04}],snareDrum:[{start:0,volume:"100%"},{start:.17,volume:"100%"},{start:.3,volume:0}]};

window.MusicManager = MusicManager
window.SONGS = {}